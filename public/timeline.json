{
  "number": 0,
  "title": "",
  "body": "[#添加](https://github.com/fzdwx/fzdwx.github.io/discussions/4) \r\n\r\n",
  "bodyHTML": "\u003cp dir=\"auto\"\u003e\u003ca href=\"https://github.com/fzdwx/fzdwx.github.io/discussions/4\" data-hovercard-type=\"discussion\" data-hovercard-url=\"/fzdwx/fzdwx.github.io/discussions/4/hovercard\"\u003e#添加\u003c/a\u003e\u003c/p\u003e",
  "locked": false,
  "upvoteCount": 0,
  "url": "https://github.com/fzdwx/fzdwx.github.io/discussions/4",
  "createdAt": "0001-01-01T00:00:00Z",
  "updatedAt": "0001-01-01T00:00:00Z",
  "author": null,
  "comments": {
    "totalCount": 12,
    "nodes": [
      {
        "databaseId": 7354350,
        "body": "Docker 安装 MySQL\r\n\r\n```shell\r\nmkdir mysql-data\r\ncd mysql-data\r\nmkdir log\r\nmkdir data\r\nmkdir conf\r\n\r\ndocker run --name mysql-dev --rm -e MYSQL_ROOT_PASSWORD=qwe -d mysql\r\ndocker cp mysql-dev:/etc/mysql ./conf/\r\ndocker stop mysql-dev\r\n\r\ndocker run -p 3306:3306 --name mysql-dev --privileged=true \\\r\n-v ./log:/var/log/mysql \\\r\n-v ./data:/var/lib/mysql \\\r\n-v ./conf/mysql:/etc/mysql \\\r\n-e MYSQL_ROOT_PASSWORD=qwe -d mysql:latest\r\n```\r\n\r\n[tags:#Docker]",
        "bodyHTML": "\u003cp dir=\"auto\"\u003eDocker 安装 MySQL\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-shell notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"mkdir mysql-data\ncd mysql-data\nmkdir log\nmkdir data\nmkdir conf\n\ndocker run --name mysql-dev --rm -e MYSQL_ROOT_PASSWORD=qwe -d mysql\ndocker cp mysql-dev:/etc/mysql ./conf/\ndocker stop mysql-dev\n\ndocker run -p 3306:3306 --name mysql-dev --privileged=true \\\n-v ./log:/var/log/mysql \\\n-v ./data:/var/lib/mysql \\\n-v ./conf/mysql:/etc/mysql \\\n-e MYSQL_ROOT_PASSWORD=qwe -d mysql:latest\"\u003e\u003cpre class=\"notranslate\"\u003emkdir mysql-data\n\u003cspan class=\"pl-c1\"\u003ecd\u003c/span\u003e mysql-data\nmkdir log\nmkdir data\nmkdir conf\n\ndocker run --name mysql-dev --rm -e MYSQL_ROOT_PASSWORD=qwe -d mysql\ndocker cp mysql-dev:/etc/mysql ./conf/\ndocker stop mysql-dev\n\ndocker run -p 3306:3306 --name mysql-dev --privileged=true \\\n-v ./log:/var/log/mysql \\\n-v ./data:/var/lib/mysql \\\n-v ./conf/mysql:/etc/mysql \\\n-e MYSQL_ROOT_PASSWORD=qwe -d mysql:latest\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e\u003c/p\u003e",
        "upvoteCount": 1,
        "url": "https://github.com/fzdwx/fzdwx.github.io/discussions/4#discussioncomment-7354350",
        "authorAssociation": "OWNER",
        "createdAt": "2023-10-23T03:28:28Z",
        "updatedAt": "2023-10-23T03:28:29Z",
        "author": {
          "login": "fzdwx",
          "avatarUrl": "https://avatars.githubusercontent.com/u/65269574?u=66e3f093a6041cfc2031dfe46a970c32b02d591e\u0026v=4",
          "url": "https://github.com/fzdwx",
          "bio": "",
          "email": "",
          "company": "",
          "location": "",
          "name": "",
          "twitterUsername": ""
        },
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ],
        "tags": [
          "#Docker"
        ]
      },
      {
        "databaseId": 7334225,
        "body": "Docker 安装 ClickHouse\r\n\r\n```shell\r\n# 准备环境\r\nmkdir clickhouse-data\r\ncd clickhouse-data\r\nmkdir data\r\nmkdir conf\r\nmkdir log\r\n\r\n# 复制配置文件\r\n\r\nsudo docker run -d --rm --name clickhouse-server --ulimit nofile=262144:262144 clickhouse/clickhouse-server\r\nsudo docker cp clickhouse-server:/etc/clickhouse-server/config.xml ./conf/config.xml\r\nsudo docker cp clickhouse-server:/etc/clickhouse-server/users.xml ./conf/users.xml\r\nsudo docker stop clickhouse-server\r\n\r\n# 启动镜像\r\nsudo docker run -d --name=clickhouse-server \\\r\n-p 8123:8123 -p 9090:9000 \\\r\n--ulimit nofile=262144:262144 \\\r\n-v ./data:/var/lib/clickhouse:rw \\\r\n-v ./conf/config.xml:/etc/clickhouse-server/config.xml \\\r\n-v ./conf/users.xml:/etc/clickhouse-server/users.xml \\\r\n-v ./log:/var/log/clickhouse-server:rw \\\r\nclickhouse/clickhouse-server\r\n```\r\n\r\n[tags:#Docker]",
        "bodyHTML": "\u003cp dir=\"auto\"\u003eDocker 安装 ClickHouse\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-shell notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"# 准备环境\nmkdir clickhouse-data\ncd clickhouse-data\nmkdir data\nmkdir conf\nmkdir log\n\n# 复制配置文件\n\nsudo docker run -d --rm --name clickhouse-server --ulimit nofile=262144:262144 clickhouse/clickhouse-server\nsudo docker cp clickhouse-server:/etc/clickhouse-server/config.xml ./conf/config.xml\nsudo docker cp clickhouse-server:/etc/clickhouse-server/users.xml ./conf/users.xml\nsudo docker stop clickhouse-server\n\n# 启动镜像\nsudo docker run -d --name=clickhouse-server \\\n-p 8123:8123 -p 9090:9000 \\\n--ulimit nofile=262144:262144 \\\n-v ./data:/var/lib/clickhouse:rw \\\n-v ./conf/config.xml:/etc/clickhouse-server/config.xml \\\n-v ./conf/users.xml:/etc/clickhouse-server/users.xml \\\n-v ./log:/var/log/clickhouse-server:rw \\\nclickhouse/clickhouse-server\"\u003e\u003cpre class=\"notranslate\"\u003e\u003cspan class=\"pl-c\"\u003e\u003cspan class=\"pl-c\"\u003e#\u003c/span\u003e 准备环境\u003c/span\u003e\nmkdir clickhouse-data\n\u003cspan class=\"pl-c1\"\u003ecd\u003c/span\u003e clickhouse-data\nmkdir data\nmkdir conf\nmkdir log\n\n\u003cspan class=\"pl-c\"\u003e\u003cspan class=\"pl-c\"\u003e#\u003c/span\u003e 复制配置文件\u003c/span\u003e\n\nsudo docker run -d --rm --name clickhouse-server --ulimit nofile=262144:262144 clickhouse/clickhouse-server\nsudo docker cp clickhouse-server:/etc/clickhouse-server/config.xml ./conf/config.xml\nsudo docker cp clickhouse-server:/etc/clickhouse-server/users.xml ./conf/users.xml\nsudo docker stop clickhouse-server\n\n\u003cspan class=\"pl-c\"\u003e\u003cspan class=\"pl-c\"\u003e#\u003c/span\u003e 启动镜像\u003c/span\u003e\nsudo docker run -d --name=clickhouse-server \\\n-p 8123:8123 -p 9090:9000 \\\n--ulimit nofile=262144:262144 \\\n-v ./data:/var/lib/clickhouse:rw \\\n-v ./conf/config.xml:/etc/clickhouse-server/config.xml \\\n-v ./conf/users.xml:/etc/clickhouse-server/users.xml \\\n-v ./log:/var/log/clickhouse-server:rw \\\nclickhouse/clickhouse-server\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e\u003c/p\u003e",
        "upvoteCount": 1,
        "url": "https://github.com/fzdwx/fzdwx.github.io/discussions/4#discussioncomment-7334225",
        "authorAssociation": "OWNER",
        "createdAt": "2023-10-20T02:46:24Z",
        "updatedAt": "2023-10-20T02:46:25Z",
        "author": {
          "login": "fzdwx",
          "avatarUrl": "https://avatars.githubusercontent.com/u/65269574?u=66e3f093a6041cfc2031dfe46a970c32b02d591e\u0026v=4",
          "url": "https://github.com/fzdwx",
          "bio": "",
          "email": "",
          "company": "",
          "location": "",
          "name": "",
          "twitterUsername": ""
        },
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ],
        "tags": [
          "#Docker"
        ]
      },
      {
        "databaseId": 7002928,
        "body": "MySQL 优化策略\r\n\r\n刷脏页: 脏页表示还没有写入磁盘的数据页. 什么情况下会触发？\r\n\r\n1. redo log 写满了\r\n2. 内存不足, 需要淘汰一些数据页, 如果淘汰的是脏页就需要 flush\r\n3. 空闲时\r\n4. 关闭 server 时\r\n\r\n1 和 2 会影响我们执行 SQL 的速度, 1 我们需要避免, 因为通常执行更新操作都是写 redo log\r\n\r\n优化方案:\r\n\r\n1. 正确的设置 innodb_io_capacity\r\n2. 关注脏页比例 `select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_total';select @a/@b;`\r\n3. 正确设置 `innodb_flush_neighbors` 来控制刷脏页时要不要一直刷临近的脏页\r\n4. 正确设置 redo log 大小\r\n\r\n[tags:#MySQL]",
        "bodyHTML": "\u003cp dir=\"auto\"\u003eMySQL 优化策略\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e刷脏页: 脏页表示还没有写入磁盘的数据页. 什么情况下会触发？\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003eredo log 写满了\u003c/li\u003e\n\u003cli\u003e内存不足, 需要淘汰一些数据页, 如果淘汰的是脏页就需要 flush\u003c/li\u003e\n\u003cli\u003e空闲时\u003c/li\u003e\n\u003cli\u003e关闭 server 时\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e1 和 2 会影响我们执行 SQL 的速度, 1 我们需要避免, 因为通常执行更新操作都是写 redo log\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e优化方案:\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e正确的设置 innodb_io_capacity\u003c/li\u003e\n\u003cli\u003e关注脏页比例 \u003ccode class=\"notranslate\"\u003eselect VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_total';select @a/@b;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e正确设置 \u003ccode class=\"notranslate\"\u003einnodb_flush_neighbors\u003c/code\u003e 来控制刷脏页时要不要一直刷临近的脏页\u003c/li\u003e\n\u003cli\u003e正确设置 redo log 大小\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e\u003c/p\u003e",
        "upvoteCount": 1,
        "url": "https://github.com/fzdwx/fzdwx.github.io/discussions/4#discussioncomment-7002928",
        "authorAssociation": "OWNER",
        "createdAt": "2023-09-14T14:59:08Z",
        "updatedAt": "2023-09-14T14:59:10Z",
        "author": {
          "login": "fzdwx",
          "avatarUrl": "https://avatars.githubusercontent.com/u/65269574?u=66e3f093a6041cfc2031dfe46a970c32b02d591e\u0026v=4",
          "url": "https://github.com/fzdwx",
          "bio": "",
          "email": "",
          "company": "",
          "location": "",
          "name": "",
          "twitterUsername": ""
        },
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ],
        "tags": [
          "#MySQL"
        ]
      },
      {
        "databaseId": 6938352,
        "body": "\r\n![image](https://github.com/fzdwx/fzdwx.github.io/assets/65269574/888a7d54-648c-4de0-b246-12198881b2ef)\r\n\r\n\r\n事务到底是隔离还是不隔离?\r\n\r\n假设在所有事务开始时 k = 1, 那么\r\n\r\n1. 事务A 读取到 k = 1\r\n2. 事务B 读取到 k = 3\r\n3. 事务C 更新 k = 2\r\n\r\n为什么会这样?\r\n\r\n1, 事务C 更新到 2 没问题\r\n2. 事务B 的更新操作为什么会读取到 2？\r\n    - 因为更新数据都是先读后写的，读这个操作是 当前读，即读取最新值\r\n    - 如果 select 加锁也会是当前读\r\n3. 事务A 因为可重复读所以还是 1\r\n\r\n也可以这样解释:\r\n\r\n1. 假设 A 的事务 id 为 99, B 为 100, C 为 101\r\n2. 事务A 的视图数组为 [99], B 为 [99,100], C 为 [99,100,101]\r\n3. id = 1 的这一行原事务 id 为 90\r\n4. 当 C 更新时, 变成了 101\r\n5. 当 B 更新时, 变成了 100\r\n6. 当 B 读取时, 100 在它的视图数组中就可以读取\r\n7. 当 A 读取时, 100 不再它的视图数组中, 就必须回滚: 100 -\u003e 101 -\u003e 90, 最后得到 1\r\n\r\n\r\n![image](https://github.com/fzdwx/fzdwx.github.io/assets/65269574/6f671417-97cd-49fc-afde-b266fac799fc)\r\n\r\n\r\n如果事务C 没有在更新完第一时间提交会怎么样?\r\n\r\n如果事务C 不提交则表明它还持有写锁, 而事务B 的 update 语句要获取读锁, 读写锁互斥, 因此被锁住了.\r\n\r\n\r\n[tags:#MySQL]",
        "bodyHTML": "\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/65269574/266354708-888a7d54-648c-4de0-b246-12198881b2ef.png\"\u003e\u003cimg src=\"https://user-images.githubusercontent.com/65269574/266354708-888a7d54-648c-4de0-b246-12198881b2ef.png\" alt=\"image\" style=\"max-width: 100%;\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e事务到底是隔离还是不隔离?\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e假设在所有事务开始时 k = 1, 那么\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e事务A 读取到 k = 1\u003c/li\u003e\n\u003cli\u003e事务B 读取到 k = 3\u003c/li\u003e\n\u003cli\u003e事务C 更新 k = 2\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e为什么会这样?\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e1, 事务C 更新到 2 没问题\u003cbr\u003e\n2. 事务B 的更新操作为什么会读取到 2？\u003cbr\u003e\n- 因为更新数据都是先读后写的，读这个操作是 当前读，即读取最新值\u003cbr\u003e\n- 如果 select 加锁也会是当前读\u003cbr\u003e\n3. 事务A 因为可重复读所以还是 1\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e也可以这样解释:\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e假设 A 的事务 id 为 99, B 为 100, C 为 101\u003c/li\u003e\n\u003cli\u003e事务A 的视图数组为 , B 为 , C 为 \u003c/li\u003e\n\u003cli\u003eid = 1 的这一行原事务 id 为 90\u003c/li\u003e\n\u003cli\u003e当 C 更新时, 变成了 101\u003c/li\u003e\n\u003cli\u003e当 B 更新时, 变成了 100\u003c/li\u003e\n\u003cli\u003e当 B 读取时, 100 在它的视图数组中就可以读取\u003c/li\u003e\n\u003cli\u003e当 A 读取时, 100 不再它的视图数组中, 就必须回滚: 100 -\u0026gt; 101 -\u0026gt; 90, 最后得到 1\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/65269574/266354656-6f671417-97cd-49fc-afde-b266fac799fc.png\"\u003e\u003cimg src=\"https://user-images.githubusercontent.com/65269574/266354656-6f671417-97cd-49fc-afde-b266fac799fc.png\" alt=\"image\" style=\"max-width: 100%;\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e如果事务C 没有在更新完第一时间提交会怎么样?\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e如果事务C 不提交则表明它还持有写锁, 而事务B 的 update 语句要获取读锁, 读写锁互斥, 因此被锁住了.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003c/p\u003e",
        "upvoteCount": 1,
        "url": "https://github.com/fzdwx/fzdwx.github.io/discussions/4#discussioncomment-6938352",
        "authorAssociation": "OWNER",
        "createdAt": "2023-09-07T14:47:17Z",
        "updatedAt": "2023-09-07T14:47:18Z",
        "author": {
          "login": "fzdwx",
          "avatarUrl": "https://avatars.githubusercontent.com/u/65269574?u=66e3f093a6041cfc2031dfe46a970c32b02d591e\u0026v=4",
          "url": "https://github.com/fzdwx",
          "bio": "",
          "email": "",
          "company": "",
          "location": "",
          "name": "",
          "twitterUsername": ""
        },
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ],
        "tags": [
          "#MySQL"
        ]
      },
      {
        "databaseId": 6915247,
        "body": "全局锁:\r\n\r\n对整个数据库实例加读锁 `Flush tables with read lock`, 使整个数据库处于只读状态, 其他更新、修改等语句会阻塞\r\n\r\n主要应用场景是全库备份, 但不推荐这样使用(除非引擎不支持事务), 备份可以用 `mysql dump` 使用参数 `-single-transcation`, 导数据之前开启一个数据, 使用视图来读取数据\r\n\r\n表锁:\r\n\r\n1. 第一种语法 `lock tables ... read/write` 可以用 `unlock tables` 主动释放, 如果使用了 `lock tables` 就只能操作指定的 `table` 且其他线程读写 lock 的表会被阻塞\r\n2. 另一种是 `MDL`, 在访问一个表的时候会自动加上. 用于保证读写的正确性\r\n    - 读锁是对一个表进行增删改查时加\r\n    - 写锁是对表结构做变更时加\r\n    - 读锁之前不互斥, 所以可以有多个线程对同一张表增删改查\r\n    - 读写锁、写锁之间是互斥的, 用于保证变更表结构操作的安全性\r\n\r\n\r\n[tags:#MySQL]",
        "bodyHTML": "\u003cp dir=\"auto\"\u003e全局锁:\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e对整个数据库实例加读锁 \u003ccode class=\"notranslate\"\u003eFlush tables with read lock\u003c/code\u003e, 使整个数据库处于只读状态, 其他更新、修改等语句会阻塞\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e主要应用场景是全库备份, 但不推荐这样使用(除非引擎不支持事务), 备份可以用 \u003ccode class=\"notranslate\"\u003emysql dump\u003c/code\u003e 使用参数 \u003ccode class=\"notranslate\"\u003e-single-transcation\u003c/code\u003e, 导数据之前开启一个数据, 使用视图来读取数据\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e表锁:\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e第一种语法 \u003ccode class=\"notranslate\"\u003elock tables ... read/write\u003c/code\u003e 可以用 \u003ccode class=\"notranslate\"\u003eunlock tables\u003c/code\u003e 主动释放, 如果使用了 \u003ccode class=\"notranslate\"\u003elock tables\u003c/code\u003e 就只能操作指定的 \u003ccode class=\"notranslate\"\u003etable\u003c/code\u003e 且其他线程读写 lock 的表会被阻塞\u003c/li\u003e\n\u003cli\u003e另一种是 \u003ccode class=\"notranslate\"\u003eMDL\u003c/code\u003e, 在访问一个表的时候会自动加上. 用于保证读写的正确性\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003e读锁是对一个表进行增删改查时加\u003c/li\u003e\n\u003cli\u003e写锁是对表结构做变更时加\u003c/li\u003e\n\u003cli\u003e读锁之前不互斥, 所以可以有多个线程对同一张表增删改查\u003c/li\u003e\n\u003cli\u003e读写锁、写锁之间是互斥的, 用于保证变更表结构操作的安全性\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e\u003c/p\u003e",
        "upvoteCount": 1,
        "url": "https://github.com/fzdwx/fzdwx.github.io/discussions/4#discussioncomment-6915247",
        "authorAssociation": "OWNER",
        "createdAt": "2023-09-05T14:29:19Z",
        "updatedAt": "2023-09-05T14:29:21Z",
        "author": {
          "login": "fzdwx",
          "avatarUrl": "https://avatars.githubusercontent.com/u/65269574?u=66e3f093a6041cfc2031dfe46a970c32b02d591e\u0026v=4",
          "url": "https://github.com/fzdwx",
          "bio": "",
          "email": "",
          "company": "",
          "location": "",
          "name": "",
          "twitterUsername": ""
        },
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ],
        "tags": [
          "#MySQL"
        ]
      },
      {
        "databaseId": 6914702,
        "body": "![image](https://github.com/fzdwx/fzdwx.github.io/assets/65269574/02e28529-c2a7-4c7b-bb8a-89679a304728)\r\n\r\n三亚的太阳\r\n\r\n[tags:#life]",
        "bodyHTML": "\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/65269574/265718863-02e28529-c2a7-4c7b-bb8a-89679a304728.png\"\u003e\u003cimg src=\"https://user-images.githubusercontent.com/65269574/265718863-02e28529-c2a7-4c7b-bb8a-89679a304728.png\" alt=\"image\" style=\"max-width: 100%;\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e三亚的太阳\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003c/p\u003e",
        "upvoteCount": 1,
        "url": "https://github.com/fzdwx/fzdwx.github.io/discussions/4#discussioncomment-6914702",
        "authorAssociation": "OWNER",
        "createdAt": "2023-09-05T13:45:42Z",
        "updatedAt": "2023-09-05T13:45:43Z",
        "author": {
          "login": "fzdwx",
          "avatarUrl": "https://avatars.githubusercontent.com/u/65269574?u=66e3f093a6041cfc2031dfe46a970c32b02d591e\u0026v=4",
          "url": "https://github.com/fzdwx",
          "bio": "",
          "email": "",
          "company": "",
          "location": "",
          "name": "",
          "twitterUsername": ""
        },
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ],
        "tags": [
          "#life"
        ]
      },
      {
        "databaseId": 6802497,
        "body": "覆盖索引\r\n\r\n这是一条建表 SQL 以及一条初始化 SQL，如果执行 `select * from T where k between 3 and 5` 需要执行几次树的搜索操作？\r\n\r\n```sql\r\ncreate table T (\r\nID int primary key,\r\nk int NOT NULL DEFAULT 0, \r\ns varchar(16) NOT NULL DEFAULT '',\r\nindex k(k))\r\nengine=InnoDB;\r\n\r\ninsert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');\r\n```\r\n\r\n![image](https://github.com/fzdwx/fzdwx.github.io/assets/65269574/676a2c4a-c450-4a68-b3db-a39099a7beee)\r\n\r\n1. 在 k 索引树上找到 k=3 的记录，取得 ID = 300\r\n2. 再到 ID 索引树查到 ID=300 对应的 R3\r\n3. 在 k 索引树取下一个值 k=5，取得 ID=500\r\n4. 再回到 ID 索引树查到 ID=500 对应的 R4\r\n5. 在 k 索引树取下一个值 k=6，不满足条件，循环结束\r\n\r\n在这个过程中读取了 k 索引树的 3 条数据以及回表 2 次，那么有没有可能避免回表操作？\r\n\r\n如果执行 `select ID from T where k between 3 and 5` 这表明只需要查询 id 的值，而 id 的值已经在 k 索引树上了，可以直接提供结果不需要回表. 也就是说，在这个查询中，索引 k 已经覆盖了我们的查询需求，这就是 **覆盖索引**\r\n\r\n\r\n最左前缀原则\r\n\r\n\u003e 联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符\r\n\r\n索引项是按照索引定义里面出现的字段顺序排序的，例如我们要找以张为姓的所有人可以用`where name like '张%' `就可以命中索引，但如果使用`'%张'` 是不会命中索引的\r\n\r\n![image](https://github.com/fzdwx/fzdwx.github.io/assets/65269574/d4950810-803a-4f9d-90f5-6abda9bccebc)\r\n\r\n索引下推\r\n\r\n最左前缀可以用于在索引中定位记录，但如果有不符合最左前缀的部分会怎么样？\r\n\r\n有一个需求是要查询名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：\r\n\r\n```sql\r\nselect * from tuser where name like '张%' and age=10 and ismale=1;\r\n```\r\n\r\n这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3，然后索引就会失效.\r\n\r\n在 MySQL5.6 以前时只能从 ID3 开始一个个回表, 到主键索引树上找出数据行然后对比数据\r\n\r\n但是在 5.6 以后可以在索引遍历过程中对索引中包含的字段先做判断，直接过滤到不满足条件的记录，减少回表次数.\r\n\r\n即以前是不会判断 age 这个字段的，但因为我们的索引是包含 age 字段的，所以现在可以利用索引下推这个功能来有优化查询速度.\r\n\r\n\r\n[tags:#MySQL]",
        "bodyHTML": "\u003cp dir=\"auto\"\u003e覆盖索引\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e这是一条建表 SQL 以及一条初始化 SQL，如果执行 \u003ccode class=\"notranslate\"\u003eselect * from T where k between 3 and 5\u003c/code\u003e 需要执行几次树的搜索操作？\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-sql notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"create table T (\nID int primary key,\nk int NOT NULL DEFAULT 0, \ns varchar(16) NOT NULL DEFAULT '',\nindex k(k))\nengine=InnoDB;\n\ninsert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');\"\u003e\u003cpre class=\"notranslate\"\u003e\u003cspan class=\"pl-k\"\u003ecreate\u003c/span\u003e \u003cspan class=\"pl-k\"\u003etable\u003c/span\u003e \u003cspan class=\"pl-en\"\u003eT\u003c/span\u003e (\nID \u003cspan class=\"pl-k\"\u003eint\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eprimary key\u003c/span\u003e,\nk \u003cspan class=\"pl-k\"\u003eint\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eNOT NULL\u003c/span\u003e DEFAULT \u003cspan class=\"pl-c1\"\u003e0\u003c/span\u003e, \ns \u003cspan class=\"pl-k\"\u003evarchar\u003c/span\u003e(\u003cspan class=\"pl-c1\"\u003e16\u003c/span\u003e) \u003cspan class=\"pl-k\"\u003eNOT NULL\u003c/span\u003e DEFAULT \u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003e\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003e\u003c/span\u003e,\nindex k(k))\nengine\u003cspan class=\"pl-k\"\u003e=\u003c/span\u003eInnoDB;\n\n\u003cspan class=\"pl-k\"\u003einsert into\u003c/span\u003e T \u003cspan class=\"pl-k\"\u003evalues\u003c/span\u003e(\u003cspan class=\"pl-c1\"\u003e100\u003c/span\u003e,\u003cspan class=\"pl-c1\"\u003e1\u003c/span\u003e, \u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003eaa\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003e\u003c/span\u003e),(\u003cspan class=\"pl-c1\"\u003e200\u003c/span\u003e,\u003cspan class=\"pl-c1\"\u003e2\u003c/span\u003e,\u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003ebb\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003e\u003c/span\u003e),(\u003cspan class=\"pl-c1\"\u003e300\u003c/span\u003e,\u003cspan class=\"pl-c1\"\u003e3\u003c/span\u003e,\u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003ecc\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003e\u003c/span\u003e),(\u003cspan class=\"pl-c1\"\u003e500\u003c/span\u003e,\u003cspan class=\"pl-c1\"\u003e5\u003c/span\u003e,\u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003eee\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003e\u003c/span\u003e),(\u003cspan class=\"pl-c1\"\u003e600\u003c/span\u003e,\u003cspan class=\"pl-c1\"\u003e6\u003c/span\u003e,\u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003eff\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003e\u003c/span\u003e),(\u003cspan class=\"pl-c1\"\u003e700\u003c/span\u003e,\u003cspan class=\"pl-c1\"\u003e7\u003c/span\u003e,\u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003egg\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003e\u003c/span\u003e);\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/65269574/262675444-676a2c4a-c450-4a68-b3db-a39099a7beee.png\"\u003e\u003cimg src=\"https://user-images.githubusercontent.com/65269574/262675444-676a2c4a-c450-4a68-b3db-a39099a7beee.png\" alt=\"image\" style=\"max-width: 100%;\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e在 k 索引树上找到 k=3 的记录，取得 ID = 300\u003c/li\u003e\n\u003cli\u003e再到 ID 索引树查到 ID=300 对应的 R3\u003c/li\u003e\n\u003cli\u003e在 k 索引树取下一个值 k=5，取得 ID=500\u003c/li\u003e\n\u003cli\u003e再回到 ID 索引树查到 ID=500 对应的 R4\u003c/li\u003e\n\u003cli\u003e在 k 索引树取下一个值 k=6，不满足条件，循环结束\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e在这个过程中读取了 k 索引树的 3 条数据以及回表 2 次，那么有没有可能避免回表操作？\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e如果执行 \u003ccode class=\"notranslate\"\u003eselect ID from T where k between 3 and 5\u003c/code\u003e 这表明只需要查询 id 的值，而 id 的值已经在 k 索引树上了，可以直接提供结果不需要回表. 也就是说，在这个查询中，索引 k 已经覆盖了我们的查询需求，这就是 \u003cstrong\u003e覆盖索引\u003c/strong\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e最左前缀原则\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp dir=\"auto\"\u003e联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp dir=\"auto\"\u003e索引项是按照索引定义里面出现的字段顺序排序的，例如我们要找以张为姓的所有人可以用\u003ccode class=\"notranslate\"\u003ewhere name like '张%' \u003c/code\u003e就可以命中索引，但如果使用\u003ccode class=\"notranslate\"\u003e'%张'\u003c/code\u003e 是不会命中索引的\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/65269574/262675423-d4950810-803a-4f9d-90f5-6abda9bccebc.png\"\u003e\u003cimg src=\"https://user-images.githubusercontent.com/65269574/262675423-d4950810-803a-4f9d-90f5-6abda9bccebc.png\" alt=\"image\" style=\"max-width: 100%;\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e索引下推\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e最左前缀可以用于在索引中定位记录，但如果有不符合最左前缀的部分会怎么样？\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e有一个需求是要查询名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-sql notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"select * from tuser where name like '张%' and age=10 and ismale=1;\"\u003e\u003cpre class=\"notranslate\"\u003e\u003cspan class=\"pl-k\"\u003eselect\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e*\u003c/span\u003e \u003cspan class=\"pl-k\"\u003efrom\u003c/span\u003e tuser \u003cspan class=\"pl-k\"\u003ewhere\u003c/span\u003e name \u003cspan class=\"pl-k\"\u003elike\u003c/span\u003e \u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003e张%\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eand\u003c/span\u003e age\u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003e10\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eand\u003c/span\u003e ismale\u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003e1\u003c/span\u003e;\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3，然后索引就会失效.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e在 MySQL5.6 以前时只能从 ID3 开始一个个回表, 到主键索引树上找出数据行然后对比数据\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e但是在 5.6 以后可以在索引遍历过程中对索引中包含的字段先做判断，直接过滤到不满足条件的记录，减少回表次数.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e即以前是不会判断 age 这个字段的，但因为我们的索引是包含 age 字段的，所以现在可以利用索引下推这个功能来有优化查询速度.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003c/p\u003e",
        "upvoteCount": 1,
        "url": "https://github.com/fzdwx/fzdwx.github.io/discussions/4#discussioncomment-6802497",
        "authorAssociation": "OWNER",
        "createdAt": "2023-08-23T12:58:08Z",
        "updatedAt": "2023-08-23T12:58:09Z",
        "author": {
          "login": "fzdwx",
          "avatarUrl": "https://avatars.githubusercontent.com/u/65269574?u=66e3f093a6041cfc2031dfe46a970c32b02d591e\u0026v=4",
          "url": "https://github.com/fzdwx",
          "bio": "",
          "email": "",
          "company": "",
          "location": "",
          "name": "",
          "twitterUsername": ""
        },
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ],
        "tags": [
          "#MySQL"
        ]
      },
      {
        "databaseId": 6801616,
        "body": "InnoDB 的索引模型:\r\n\r\n在 InnoDB 中，每一个索引都对应一颗 B+ 树，有下面的建表 SQL，id 与 k 都是索引列: \r\n\r\n```sql\r\ncreate table T(\r\nid int primary key, \r\nk int not null, \r\nname varchar(16),\r\nindex (k) \r\n)engine=InnoDB;\r\n```\r\n\r\n![image](https://github.com/fzdwx/fzdwx.github.io/assets/65269574/76da8d26-f9ba-4f81-8caf-cac848f97b4b)\r\n\r\n\r\n可以看出索引分为 主键索引 以及  非主键索引\r\n\r\n1. `主键索引`(聚簇索引的叶子节点存放了整行的数据,\r\n2. `非主建索引`(二级索引)的叶子节点存放的是主键的值\r\n\r\n基于主键索引和普通索引的查询有什么区别?\r\n\r\n- 如果是 `select * from t where id = 1` 使用主键索引则只需要查找 `ID` 索引树\r\n- 如果是 `select * from t where k = 6` 则需要先查找 `k` 索引树然后在到  `ID` 索引树中在查找. 这个过程就是 **回表**\r\n\r\n为什么推荐使用自增主键？\r\n\r\nB+树为了保证索引的有序性，在插入以及删除值的时候进行必要的维护.以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。\r\n\r\n而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。\r\n\r\n而使用一个递增的主键就可以保证每次插入都是追加，写数据性能就会提高.\r\n\r\n[tags:#MySQL]\r\n",
        "bodyHTML": "\u003cp dir=\"auto\"\u003eInnoDB 的索引模型:\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e在 InnoDB 中，每一个索引都对应一颗 B+ 树，有下面的建表 SQL，id 与 k 都是索引列:\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-sql notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"create table T(\nid int primary key, \nk int not null, \nname varchar(16),\nindex (k) \n)engine=InnoDB;\"\u003e\u003cpre class=\"notranslate\"\u003e\u003cspan class=\"pl-k\"\u003ecreate\u003c/span\u003e \u003cspan class=\"pl-k\"\u003etable\u003c/span\u003e \u003cspan class=\"pl-en\"\u003eT\u003c/span\u003e(\nid \u003cspan class=\"pl-k\"\u003eint\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eprimary key\u003c/span\u003e, \nk \u003cspan class=\"pl-k\"\u003eint\u003c/span\u003e \u003cspan class=\"pl-k\"\u003enot null\u003c/span\u003e, \nname \u003cspan class=\"pl-k\"\u003evarchar\u003c/span\u003e(\u003cspan class=\"pl-c1\"\u003e16\u003c/span\u003e),\nindex (k) \n)engine\u003cspan class=\"pl-k\"\u003e=\u003c/span\u003eInnoDB;\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/65269574/262654721-76da8d26-f9ba-4f81-8caf-cac848f97b4b.png\"\u003e\u003cimg src=\"https://user-images.githubusercontent.com/65269574/262654721-76da8d26-f9ba-4f81-8caf-cac848f97b4b.png\" alt=\"image\" style=\"max-width: 100%;\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e可以看出索引分为 主键索引 以及  非主键索引\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e\u003ccode class=\"notranslate\"\u003e主键索引\u003c/code\u003e(聚簇索引的叶子节点存放了整行的数据,\u003c/li\u003e\n\u003cli\u003e\u003ccode class=\"notranslate\"\u003e非主建索引\u003c/code\u003e(二级索引)的叶子节点存放的是主键的值\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e基于主键索引和普通索引的查询有什么区别?\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003e如果是 \u003ccode class=\"notranslate\"\u003eselect * from t where id = 1\u003c/code\u003e 使用主键索引则只需要查找 \u003ccode class=\"notranslate\"\u003eID\u003c/code\u003e 索引树\u003c/li\u003e\n\u003cli\u003e如果是 \u003ccode class=\"notranslate\"\u003eselect * from t where k = 6\u003c/code\u003e 则需要先查找 \u003ccode class=\"notranslate\"\u003ek\u003c/code\u003e 索引树然后在到  \u003ccode class=\"notranslate\"\u003eID\u003c/code\u003e 索引树中在查找. 这个过程就是 \u003cstrong\u003e回表\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp dir=\"auto\"\u003e为什么推荐使用自增主键？\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eB+树为了保证索引的有序性，在插入以及删除值的时候进行必要的维护.以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e而使用一个递增的主键就可以保证每次插入都是追加，写数据性能就会提高.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003c/p\u003e",
        "upvoteCount": 1,
        "url": "https://github.com/fzdwx/fzdwx.github.io/discussions/4#discussioncomment-6801616",
        "authorAssociation": "OWNER",
        "createdAt": "2023-08-23T11:31:36Z",
        "updatedAt": "2023-08-23T11:31:37Z",
        "author": {
          "login": "fzdwx",
          "avatarUrl": "https://avatars.githubusercontent.com/u/65269574?u=66e3f093a6041cfc2031dfe46a970c32b02d591e\u0026v=4",
          "url": "https://github.com/fzdwx",
          "bio": "",
          "email": "",
          "company": "",
          "location": "",
          "name": "",
          "twitterUsername": ""
        },
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ],
        "tags": [
          "#MySQL"
        ]
      },
      {
        "databaseId": 6800370,
        "body": "事务之隔离性\r\n\r\n当数据库上有多个事务同时执行的时候，就可能出现脏读、不可重复读、幻读等问题，这就需要靠隔离级别来解决.\r\n\r\n隔离级别包括:\r\n\r\n1. 读未提交: 一个事务还没提交时，它的变更就能被其他事务看到\r\n    - 直接返回记录上的最新值\r\n2. 读提交: 一个事务提交后，它做的变更才会被其他事务看到\r\n    - 视图在每个 SQL 语句开始执行的时候创建的\r\n3. 可重复读: 一个事务执行过程中看到的数据，总是跟这个事务在启\r\n动是看到的数据是一致的，当然这个事务的变更也对其他事务不可见\r\n    - 在事务启动时创建视图, 整个事务都使用这个视图来访问数据\r\n4. 串行:  对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行\r\n    - 直接用加锁的方式来避免并行访问\r\n\r\n\r\nMySQL 默认隔离级别是 可重复读，Oracle 是 读提交.\r\n\r\n怎么实现事务隔离?\r\n\r\n1. 每条 SQL 执行后都会记录一条对应的回滚操作 undo log\r\n2. 不同时刻启动的事务都有不同的 视图\r\n\r\n这就会使得一条记录在系统中的同一时刻会有不同的版本，如果视图 A 要得到 1，就必须依次执行下面的所有回滚操作得到\r\n\r\n![image](https://github.com/fzdwx/fzdwx.github.io/assets/65269574/09107efb-92a6-439f-a87b-d047d3a56b3f)\r\n\r\n\r\n[tags:#MySQL]",
        "bodyHTML": "\u003cp dir=\"auto\"\u003e事务之隔离性\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e当数据库上有多个事务同时执行的时候，就可能出现脏读、不可重复读、幻读等问题，这就需要靠隔离级别来解决.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e隔离级别包括:\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e读未提交: 一个事务还没提交时，它的变更就能被其他事务看到\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003e直接返回记录上的最新值\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e读提交: 一个事务提交后，它做的变更才会被其他事务看到\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003e视图在每个 SQL 语句开始执行的时候创建的\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e可重复读: 一个事务执行过程中看到的数据，总是跟这个事务在启\u003cbr\u003e\n动是看到的数据是一致的，当然这个事务的变更也对其他事务不可见\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003e在事务启动时创建视图, 整个事务都使用这个视图来访问数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e串行:  对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003e直接用加锁的方式来避免并行访问\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003eMySQL 默认隔离级别是 可重复读，Oracle 是 读提交.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e怎么实现事务隔离?\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e每条 SQL 执行后都会记录一条对应的回滚操作 undo log\u003c/li\u003e\n\u003cli\u003e不同时刻启动的事务都有不同的 视图\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e这就会使得一条记录在系统中的同一时刻会有不同的版本，如果视图 A 要得到 1，就必须依次执行下面的所有回滚操作得到\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/65269574/262619809-09107efb-92a6-439f-a87b-d047d3a56b3f.png\"\u003e\u003cimg src=\"https://user-images.githubusercontent.com/65269574/262619809-09107efb-92a6-439f-a87b-d047d3a56b3f.png\" alt=\"image\" style=\"max-width: 100%;\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003c/p\u003e",
        "upvoteCount": 1,
        "url": "https://github.com/fzdwx/fzdwx.github.io/discussions/4#discussioncomment-6800370",
        "authorAssociation": "OWNER",
        "createdAt": "2023-08-23T09:13:24Z",
        "updatedAt": "2023-08-23T09:13:25Z",
        "author": {
          "login": "fzdwx",
          "avatarUrl": "https://avatars.githubusercontent.com/u/65269574?u=66e3f093a6041cfc2031dfe46a970c32b02d591e\u0026v=4",
          "url": "https://github.com/fzdwx",
          "bio": "",
          "email": "",
          "company": "",
          "location": "",
          "name": "",
          "twitterUsername": ""
        },
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ],
        "tags": [
          "#MySQL"
        ]
      },
      {
        "databaseId": 6779905,
        "body": "书籍收藏:\r\n\r\n1. DDIA(设计数据密集型应用程序)\r\n\t- [中文翻译](https://github.com/Vonng/ddia)\r\n\t- [逐章精读](https://github.com/DistSysCorp/ddia)\r\n2. Rust Atomics and Locks\r\n\t- [中文翻译](https://github.com/rustcc/Rust_Atomics_and_Locks)\r\n3. [深入架构原理与实践](https://github.com/isno/theByteBook)\r\n\r\n[tags:#book]",
        "bodyHTML": "\u003cp dir=\"auto\"\u003e书籍收藏:\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003eDDIA(设计数据密集型应用程序)\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Vonng/ddia\"\u003e中文翻译\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/DistSysCorp/ddia\"\u003e逐章精读\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eRust Atomics and Locks\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/rustcc/Rust_Atomics_and_Locks\"\u003e中文翻译\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/isno/theByteBook\"\u003e深入架构原理与实践\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e\u003c/p\u003e",
        "upvoteCount": 1,
        "url": "https://github.com/fzdwx/fzdwx.github.io/discussions/4#discussioncomment-6779905",
        "authorAssociation": "OWNER",
        "createdAt": "2023-08-21T11:32:09Z",
        "updatedAt": "2023-08-21T11:32:22Z",
        "author": {
          "login": "fzdwx",
          "avatarUrl": "https://avatars.githubusercontent.com/u/65269574?u=66e3f093a6041cfc2031dfe46a970c32b02d591e\u0026v=4",
          "url": "https://github.com/fzdwx",
          "bio": "",
          "email": "",
          "company": "",
          "location": "",
          "name": "",
          "twitterUsername": ""
        },
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ],
        "tags": [
          "#book"
        ]
      },
      {
        "databaseId": 6668339,
        "body": "一条更新 SQL 的执行流程:\r\n\r\n1. 总体流程和查询的 SQL 执行流程类似, 但更新流程涉及到两个重要的日志模块: redo log(重做日志), binlog(归档日志)\r\n2. 关键点是先写日志, 在写磁盘 —— InnoDB 会先把记录写道 redo log 里面并更新内存, 这个时候更新操作就算完成了, 后续会在适当的时候写入到磁盘中(比如系统比较空闲). \r\n\r\n重要的日志模块: redo log\r\n\r\nInnoDB 的 redo log 是固定大小的, 比如可以配置为一组 4 个文件, 每个文件的大小是 1GB, 即总容量是 4GB. 从头开始写, 写倒末尾就就又回到开头循环写:\r\n\r\n![image](https://github.com/fzdwx/fzdwx.github.io/assets/65269574/4907b5f2-8ff2-49e4-af00-d3a39dfd2822)\r\n\r\n1. `write pos` 是当前记录的位置, 一边写一边后移, 写到 3 号文件末尾就会到 0 号文件重新开始\r\n2. `check point` 是当前要擦除的位置, 同样是循环的, 擦除记录前要把记录更新到数据文件\r\n3. `write pos` 和 `check point` 之间的空间就是可以用来记录新的操作, 如果这两个值相等就表示不能继续写了, 得先写入一些数据到磁盘(`check point` 擦除).\r\n\r\n有了 redo log, InnoDB 可以保证即使数据库发生异常重启, 之前提交的记录都不会丢失 —— crach-safe\r\n\r\n重要的日志模块: binlog\r\n\r\nbinlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。\r\n\r\n1. binlog server 自带的而 redo log 是 InnoDB 独有的\r\n2. redo log 是物理日志, 记录了在某个数据页上做了什么修改, binglog 是逻辑日志, 记录的是语句的原始逻辑, 比如\"给 ID = 2 的这一行的 age 字段加 1\"\r\n3. redo log 是循环写, binglog 是追加的, 在文件到达一定大小会切换到下一个\r\n\r\n\r\n所以执行器和引擎执行更新 SQL 的流程:\r\n\r\n1. 执行器先找引擎取 ID = 2 的这一行, 假如 ID 为主键, 引擎就直接用树搜索找到这一行, 如果这一行所在的数据页本来就在内存中, 就直接返回, 否则就先从磁盘读入内存然后返回\r\n2. 执行器拿到引擎给的数据, 执行更新操作, 然后在调用引擎写入数据\r\n3. 引擎将这行数据更新到内存中, 同时将更新操作记录到 redo log 中, 此时 redo log 处于 `prepare` 状态. 然后告知执行器执行完成了, 随时可以提交事务\r\n4. 执行器生成这个操作的 binlog, 并把 binlog 写入磁盘\r\n5. 执行器调用引擎的提交事务接口, 引擎把刚刚写入的 redo log 改为 `commit` 状态, 更新完成\r\n\r\n![image](https://github.com/fzdwx/fzdwx.github.io/assets/65269574/f8d1bf3f-1053-4137-82f6-f4e5548e8e09)\r\n\r\n\r\n为什么需要两阶段提交?\r\n\r\n1. 如果在 prepare 阶段崩溃, 重启恢复后发现没有 commit 会回滚. 备份恢复, 发现没有这条记录的 binlog. 数据一致\r\n2. 如果在 commit 时崩溃, 重启恢复时满足 prepare 和 binlog 完整会自动 commit . 备份恢复时有binlog 数据一致\r\n\r\n[tags:#MySQL]",
        "bodyHTML": "\u003cp dir=\"auto\"\u003e一条更新 SQL 的执行流程:\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e总体流程和查询的 SQL 执行流程类似, 但更新流程涉及到两个重要的日志模块: redo log(重做日志), binlog(归档日志)\u003c/li\u003e\n\u003cli\u003e关键点是先写日志, 在写磁盘 —— InnoDB 会先把记录写道 redo log 里面并更新内存, 这个时候更新操作就算完成了, 后续会在适当的时候写入到磁盘中(比如系统比较空闲).\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e重要的日志模块: redo log\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eInnoDB 的 redo log 是固定大小的, 比如可以配置为一组 4 个文件, 每个文件的大小是 1GB, 即总容量是 4GB. 从头开始写, 写倒末尾就就又回到开头循环写:\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/65269574/259082685-4907b5f2-8ff2-49e4-af00-d3a39dfd2822.png\"\u003e\u003cimg src=\"https://user-images.githubusercontent.com/65269574/259082685-4907b5f2-8ff2-49e4-af00-d3a39dfd2822.png\" alt=\"image\" style=\"max-width: 100%;\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e\u003ccode class=\"notranslate\"\u003ewrite pos\u003c/code\u003e 是当前记录的位置, 一边写一边后移, 写到 3 号文件末尾就会到 0 号文件重新开始\u003c/li\u003e\n\u003cli\u003e\u003ccode class=\"notranslate\"\u003echeck point\u003c/code\u003e 是当前要擦除的位置, 同样是循环的, 擦除记录前要把记录更新到数据文件\u003c/li\u003e\n\u003cli\u003e\u003ccode class=\"notranslate\"\u003ewrite pos\u003c/code\u003e 和 \u003ccode class=\"notranslate\"\u003echeck point\u003c/code\u003e 之间的空间就是可以用来记录新的操作, 如果这两个值相等就表示不能继续写了, 得先写入一些数据到磁盘(\u003ccode class=\"notranslate\"\u003echeck point\u003c/code\u003e 擦除).\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e有了 redo log, InnoDB 可以保证即使数据库发生异常重启, 之前提交的记录都不会丢失 —— crach-safe\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e重要的日志模块: binlog\u003c/p\u003e\n\u003cp dir=\"auto\"\u003ebinlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003ebinlog server 自带的而 redo log 是 InnoDB 独有的\u003c/li\u003e\n\u003cli\u003eredo log 是物理日志, 记录了在某个数据页上做了什么修改, binglog 是逻辑日志, 记录的是语句的原始逻辑, 比如\"给 ID = 2 的这一行的 age 字段加 1\"\u003c/li\u003e\n\u003cli\u003eredo log 是循环写, binglog 是追加的, 在文件到达一定大小会切换到下一个\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e所以执行器和引擎执行更新 SQL 的流程:\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e执行器先找引擎取 ID = 2 的这一行, 假如 ID 为主键, 引擎就直接用树搜索找到这一行, 如果这一行所在的数据页本来就在内存中, 就直接返回, 否则就先从磁盘读入内存然后返回\u003c/li\u003e\n\u003cli\u003e执行器拿到引擎给的数据, 执行更新操作, 然后在调用引擎写入数据\u003c/li\u003e\n\u003cli\u003e引擎将这行数据更新到内存中, 同时将更新操作记录到 redo log 中, 此时 redo log 处于 \u003ccode class=\"notranslate\"\u003eprepare\u003c/code\u003e 状态. 然后告知执行器执行完成了, 随时可以提交事务\u003c/li\u003e\n\u003cli\u003e执行器生成这个操作的 binlog, 并把 binlog 写入磁盘\u003c/li\u003e\n\u003cli\u003e执行器调用引擎的提交事务接口, 引擎把刚刚写入的 redo log 改为 \u003ccode class=\"notranslate\"\u003ecommit\u003c/code\u003e 状态, 更新完成\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/65269574/259111370-f8d1bf3f-1053-4137-82f6-f4e5548e8e09.png\"\u003e\u003cimg src=\"https://user-images.githubusercontent.com/65269574/259111370-f8d1bf3f-1053-4137-82f6-f4e5548e8e09.png\" alt=\"image\" style=\"max-width: 100%;\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e为什么需要两阶段提交?\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e如果在 prepare 阶段崩溃, 重启恢复后发现没有 commit 会回滚. 备份恢复, 发现没有这条记录的 binlog. 数据一致\u003c/li\u003e\n\u003cli\u003e如果在 commit 时崩溃, 重启恢复时满足 prepare 和 binlog 完整会自动 commit . 备份恢复时有binlog 数据一致\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e\u003c/p\u003e",
        "upvoteCount": 1,
        "url": "https://github.com/fzdwx/fzdwx.github.io/discussions/4#discussioncomment-6668339",
        "authorAssociation": "OWNER",
        "createdAt": "2023-08-08T11:26:39Z",
        "updatedAt": "2023-08-08T13:18:35Z",
        "author": {
          "login": "fzdwx",
          "avatarUrl": "https://avatars.githubusercontent.com/u/65269574?u=66e3f093a6041cfc2031dfe46a970c32b02d591e\u0026v=4",
          "url": "https://github.com/fzdwx",
          "bio": "",
          "email": "",
          "company": "",
          "location": "",
          "name": "",
          "twitterUsername": ""
        },
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ],
        "tags": [
          "#MySQL"
        ]
      },
      {
        "databaseId": 6643890,
        "body": "一条查询 SQL 的执行过程:\r\n\r\n1.  client 与连接器建立连接，连接器确认 client 认证信息以及权限信息\r\n2. 分析器进行词法分析(select, where, update, group by...), 然后进行语法分析\r\n3. 优化器选择索引生成执行计划\r\n4. 执行器调用存储引擎的读写接口进行数据查询\r\n\r\n![image](https://github.com/fzdwx/fzdwx.github.io/assets/65269574/645e5834-d596-4c9e-b4d7-cb10365d60a3)\r\n\r\n\r\n\r\n[tags:#MySQL]",
        "bodyHTML": "\u003cp dir=\"auto\"\u003e一条查询 SQL 的执行过程:\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003eclient 与连接器建立连接，连接器确认 client 认证信息以及权限信息\u003c/li\u003e\n\u003cli\u003e分析器进行词法分析(select, where, update, group by...), 然后进行语法分析\u003c/li\u003e\n\u003cli\u003e优化器选择索引生成执行计划\u003c/li\u003e\n\u003cli\u003e执行器调用存储引擎的读写接口进行数据查询\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/65269574/258571472-645e5834-d596-4c9e-b4d7-cb10365d60a3.png\"\u003e\u003cimg src=\"https://user-images.githubusercontent.com/65269574/258571472-645e5834-d596-4c9e-b4d7-cb10365d60a3.png\" alt=\"image\" style=\"max-width: 100%;\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003c/p\u003e",
        "upvoteCount": 1,
        "url": "https://github.com/fzdwx/fzdwx.github.io/discussions/4#discussioncomment-6643890",
        "authorAssociation": "OWNER",
        "createdAt": "2023-08-05T05:12:23Z",
        "updatedAt": "2023-08-05T11:59:50Z",
        "author": {
          "login": "fzdwx",
          "avatarUrl": "https://avatars.githubusercontent.com/u/65269574?u=66e3f093a6041cfc2031dfe46a970c32b02d591e\u0026v=4",
          "url": "https://github.com/fzdwx",
          "bio": "",
          "email": "",
          "company": "",
          "location": "",
          "name": "",
          "twitterUsername": ""
        },
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ],
        "tags": [
          "#MySQL"
        ]
      }
    ],
    "pageInfo": {
      "hasNextPage": false,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0xMC0yM1QxMToyODoyOCswODowMM4AcDfu"
    }
  },
  "reactionGroups": null
}
