{"number":0,"title":"","body":"[#添加](https://github.com/fzdwx/fzdwx.github.io/discussions/4) \r\n\r\n","bodyHTML":"\u003cp dir=\"auto\"\u003e\u003ca href=\"https://github.com/fzdwx/fzdwx.github.io/discussions/4\" data-hovercard-type=\"discussion\" data-hovercard-url=\"/fzdwx/fzdwx.github.io/discussions/4/hovercard\"\u003e#添加\u003c/a\u003e\u003c/p\u003e","locked":false,"upvoteCount":0,"url":"https://github.com/fzdwx/fzdwx.github.io/discussions/4","createdAt":"0001-01-01T00:00:00Z","updatedAt":"0001-01-01T00:00:00Z","author":null,"comments":{"totalCount":3,"nodes":[{"body":"一条更新 SQL 的执行流程:\r\n\r\n1. 总体流程和查询的 SQL 执行流程类似, 但更新流程涉及到两个重要的日志模块: redo log(重做日志), binlog(归档日志)\r\n2. 关键点是先写日志, 在写磁盘 —— InnoDB 会先把记录写道 redo log 里面并更新内存, 这个时候更新操作就算完成了, 后续会在适当的时候写入到磁盘中(比如系统比较空闲). \r\n\r\n重要的日志模块: redo log\r\n\r\nInnoDB 的 redo log 是固定大小的, 比如可以配置为一组 4 个文件, 每个文件的大小是 1GB, 即总容量是 4GB. 从头开始写, 写倒末尾就就又回到开头循环写:\r\n\r\n![image](https://github.com/fzdwx/fzdwx.github.io/assets/65269574/4907b5f2-8ff2-49e4-af00-d3a39dfd2822)\r\n\r\n1. `write pos` 是当前记录的位置, 一边写一边后移, 写到 3 号文件末尾就会到 0 号文件重新开始\r\n2. `check point` 是当前要擦除的位置, 同样是循环的, 擦除记录前要把记录更新到数据文件\r\n3. `write pos` 和 `check point` 之间的空间就是可以用来记录新的操作, 如果这两个值相等就表示不能继续写了, 得先写入一些数据到磁盘(`check point` 擦除).\r\n\r\n有了 redo log, InnoDB 可以保证即使数据库发生异常重启, 之前提交的记录都不会丢失 —— crach-safe\r\n\r\n重要的日志模块: binlog\r\n\r\nbinlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。\r\n\r\n1. binlog server 自带的而 redo log 是 InnoDB 独有的\r\n2. redo log 是物理日志, 记录了在某个数据页上做了什么修改, binglog 是逻辑日志, 记录的是语句的原始逻辑, 比如\"给 ID = 2 的这一行的 age 字段加 1\"\r\n3. redo log 是循环写, binglog 是追加的, 在文件到达一定大小会切换到下一个\r\n\r\n\r\n所以执行器和引擎执行更新 SQL 的流程:\r\n\r\n1. 执行器先找引擎取 ID = 2 的这一行, 假如 ID 为主键, 引擎就直接用树搜索找到这一行, 如果这一行所在的数据页本来就在内存中, 就直接返回, 否则就先从磁盘读入内存然后返回\r\n2. 执行器拿到引擎给的数据, 执行更新操作, 然后在调用引擎写入数据\r\n3. 引擎将这行数据更新到内存中, 同时将更新操作记录到 redo log 中, 此时 redo log 处于 `prepare` 状态. 然后告知执行器执行完成了, 随时可以提交事务\r\n4. 执行器生成这个操作的 binlog, 并把 binlog 写入磁盘\r\n5. 执行器调用引擎的提交事务接口, 引擎把刚刚写入的 redo log 改为 `commit` 状态, 更新完成\r\n\r\n![image](https://github.com/fzdwx/fzdwx.github.io/assets/65269574/f8d1bf3f-1053-4137-82f6-f4e5548e8e09)\r\n\r\n\r\n为什么需要两阶段提交?\r\n\r\n1. 如果在 prepare 阶段崩溃, 重启恢复后发现没有 commit 会回滚. 备份恢复, 发现没有这条记录的 binlog. 数据一致\r\n2. 如果在 commit 时崩溃, 重启恢复时满足 prepare 和 binlog 完整会自动 commit . 备份恢复时有binlog 数据一致\r\n\r\n[tags:#MySQL]","bodyHTML":"\u003cp dir=\"auto\"\u003e一条更新 SQL 的执行流程:\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e总体流程和查询的 SQL 执行流程类似, 但更新流程涉及到两个重要的日志模块: redo log(重做日志), binlog(归档日志)\u003c/li\u003e\n\u003cli\u003e关键点是先写日志, 在写磁盘 —— InnoDB 会先把记录写道 redo log 里面并更新内存, 这个时候更新操作就算完成了, 后续会在适当的时候写入到磁盘中(比如系统比较空闲).\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e重要的日志模块: redo log\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eInnoDB 的 redo log 是固定大小的, 比如可以配置为一组 4 个文件, 每个文件的大小是 1GB, 即总容量是 4GB. 从头开始写, 写倒末尾就就又回到开头循环写:\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/65269574/259082685-4907b5f2-8ff2-49e4-af00-d3a39dfd2822.png\"\u003e\u003cimg src=\"https://user-images.githubusercontent.com/65269574/259082685-4907b5f2-8ff2-49e4-af00-d3a39dfd2822.png\" alt=\"image\" style=\"max-width: 100%;\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e\u003ccode class=\"notranslate\"\u003ewrite pos\u003c/code\u003e 是当前记录的位置, 一边写一边后移, 写到 3 号文件末尾就会到 0 号文件重新开始\u003c/li\u003e\n\u003cli\u003e\u003ccode class=\"notranslate\"\u003echeck point\u003c/code\u003e 是当前要擦除的位置, 同样是循环的, 擦除记录前要把记录更新到数据文件\u003c/li\u003e\n\u003cli\u003e\u003ccode class=\"notranslate\"\u003ewrite pos\u003c/code\u003e 和 \u003ccode class=\"notranslate\"\u003echeck point\u003c/code\u003e 之间的空间就是可以用来记录新的操作, 如果这两个值相等就表示不能继续写了, 得先写入一些数据到磁盘(\u003ccode class=\"notranslate\"\u003echeck point\u003c/code\u003e 擦除).\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e有了 redo log, InnoDB 可以保证即使数据库发生异常重启, 之前提交的记录都不会丢失 —— crach-safe\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e重要的日志模块: binlog\u003c/p\u003e\n\u003cp dir=\"auto\"\u003ebinlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003ebinlog server 自带的而 redo log 是 InnoDB 独有的\u003c/li\u003e\n\u003cli\u003eredo log 是物理日志, 记录了在某个数据页上做了什么修改, binglog 是逻辑日志, 记录的是语句的原始逻辑, 比如\"给 ID = 2 的这一行的 age 字段加 1\"\u003c/li\u003e\n\u003cli\u003eredo log 是循环写, binglog 是追加的, 在文件到达一定大小会切换到下一个\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e所以执行器和引擎执行更新 SQL 的流程:\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e执行器先找引擎取 ID = 2 的这一行, 假如 ID 为主键, 引擎就直接用树搜索找到这一行, 如果这一行所在的数据页本来就在内存中, 就直接返回, 否则就先从磁盘读入内存然后返回\u003c/li\u003e\n\u003cli\u003e执行器拿到引擎给的数据, 执行更新操作, 然后在调用引擎写入数据\u003c/li\u003e\n\u003cli\u003e引擎将这行数据更新到内存中, 同时将更新操作记录到 redo log 中, 此时 redo log 处于 \u003ccode class=\"notranslate\"\u003eprepare\u003c/code\u003e 状态. 然后告知执行器执行完成了, 随时可以提交事务\u003c/li\u003e\n\u003cli\u003e执行器生成这个操作的 binlog, 并把 binlog 写入磁盘\u003c/li\u003e\n\u003cli\u003e执行器调用引擎的提交事务接口, 引擎把刚刚写入的 redo log 改为 \u003ccode class=\"notranslate\"\u003ecommit\u003c/code\u003e 状态, 更新完成\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/65269574/259111370-f8d1bf3f-1053-4137-82f6-f4e5548e8e09.png\"\u003e\u003cimg src=\"https://user-images.githubusercontent.com/65269574/259111370-f8d1bf3f-1053-4137-82f6-f4e5548e8e09.png\" alt=\"image\" style=\"max-width: 100%;\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e为什么需要两阶段提交?\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e如果在 prepare 阶段崩溃, 重启恢复后发现没有 commit 会回滚. 备份恢复, 发现没有这条记录的 binlog. 数据一致\u003c/li\u003e\n\u003cli\u003e如果在 commit 时崩溃, 重启恢复时满足 prepare 和 binlog 完整会自动 commit . 备份恢复时有binlog 数据一致\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e\u003c/p\u003e","upvoteCount":1,"url":"https://github.com/fzdwx/fzdwx.github.io/discussions/4#discussioncomment-6668339","authorAssociation":"OWNER","createdAt":"2023-08-08T11:26:39Z","updatedAt":"2023-08-08T13:18:35Z","author":{"login":"fzdwx","avatarUrl":"https://avatars.githubusercontent.com/u/65269574?u=ed3f913168ed04029c8cc0c2504b30299d2bde75\u0026v=4","url":"https://github.com/fzdwx","bio":"","email":"","company":"","location":"","name":"","twitterUsername":""},"reactionGroups":[{"content":"THUMBS_UP","reactors":{"totalCount":0}},{"content":"THUMBS_DOWN","reactors":{"totalCount":0}},{"content":"LAUGH","reactors":{"totalCount":0}},{"content":"HOORAY","reactors":{"totalCount":0}},{"content":"CONFUSED","reactors":{"totalCount":0}},{"content":"HEART","reactors":{"totalCount":0}},{"content":"ROCKET","reactors":{"totalCount":0}},{"content":"EYES","reactors":{"totalCount":0}}],"tags":["#MySQL"]},{"body":"fork 系统调用:\r\n\r\n1. 在内核初始化完毕后会调用用户初始化进程 `init`, 在 linux 上可以通过指定 `rdinit` 来设置\r\n2. 进程 A 调用 `fork` 后内核会创建一个进程 B, 它们在 `fork` 系统调用返回时几乎处于相同的状态(用户态代码段、堆栈段以及其他数据段), 但是出于两个不同地址空间, 只有返回值不同(`a0`寄存器), 父进程返回子进程 pid, 子进程返回 0\r\n\r\n\r\nwaitpid 系统调用:\r\n\r\n1. 当一个进程调用 `exit` 退出后, 它所占用的资源不能立即全部回收. 比如当前进程的内核栈正在执行系统调用, 所以这种进程退出的时候内核立即回收一部分资源标记为 僵尸进程.\r\n2. 接下来会由父进程通过 waitpid 来收集该进程的返回状态并回收资源\r\n3. 如果父进程先于子进程结束则由 init 来处理\r\n\r\nexec 系统调用:\r\n\r\n1. 将当前进程的地址空间清空并加载一个特定的可执行文件, 返回用户态后就开始执行\r\n\r\n[tags:#os]","bodyHTML":"\u003cp dir=\"auto\"\u003efork 系统调用:\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e在内核初始化完毕后会调用用户初始化进程 \u003ccode class=\"notranslate\"\u003einit\u003c/code\u003e, 在 linux 上可以通过指定 \u003ccode class=\"notranslate\"\u003erdinit\u003c/code\u003e 来设置\u003c/li\u003e\n\u003cli\u003e进程 A 调用 \u003ccode class=\"notranslate\"\u003efork\u003c/code\u003e 后内核会创建一个进程 B, 它们在 \u003ccode class=\"notranslate\"\u003efork\u003c/code\u003e 系统调用返回时几乎处于相同的状态(用户态代码段、堆栈段以及其他数据段), 但是出于两个不同地址空间, 只有返回值不同(\u003ccode class=\"notranslate\"\u003ea0\u003c/code\u003e寄存器), 父进程返回子进程 pid, 子进程返回 0\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003ewaitpid 系统调用:\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e当一个进程调用 \u003ccode class=\"notranslate\"\u003eexit\u003c/code\u003e 退出后, 它所占用的资源不能立即全部回收. 比如当前进程的内核栈正在执行系统调用, 所以这种进程退出的时候内核立即回收一部分资源标记为 僵尸进程.\u003c/li\u003e\n\u003cli\u003e接下来会由父进程通过 waitpid 来收集该进程的返回状态并回收资源\u003c/li\u003e\n\u003cli\u003e如果父进程先于子进程结束则由 init 来处理\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003eexec 系统调用:\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e将当前进程的地址空间清空并加载一个特定的可执行文件, 返回用户态后就开始执行\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e\u003c/p\u003e","upvoteCount":1,"url":"https://github.com/fzdwx/fzdwx.github.io/discussions/4#discussioncomment-6645264","authorAssociation":"OWNER","createdAt":"2023-08-05T11:56:36Z","updatedAt":"2023-08-05T16:43:06Z","author":{"login":"fzdwx","avatarUrl":"https://avatars.githubusercontent.com/u/65269574?u=ed3f913168ed04029c8cc0c2504b30299d2bde75\u0026v=4","url":"https://github.com/fzdwx","bio":"","email":"","company":"","location":"","name":"","twitterUsername":""},"reactionGroups":[{"content":"THUMBS_UP","reactors":{"totalCount":0}},{"content":"THUMBS_DOWN","reactors":{"totalCount":0}},{"content":"LAUGH","reactors":{"totalCount":0}},{"content":"HOORAY","reactors":{"totalCount":0}},{"content":"CONFUSED","reactors":{"totalCount":0}},{"content":"HEART","reactors":{"totalCount":0}},{"content":"ROCKET","reactors":{"totalCount":0}},{"content":"EYES","reactors":{"totalCount":0}}],"tags":["#os"]},{"body":"一条查询 SQL 的执行过程:\r\n\r\n1.  client 与连接器建立连接，连接器确认 client 认证信息以及权限信息\r\n2. 分析器进行词法分析(select, where, update, group by...), 然后进行语法分析\r\n3. 优化器选择索引生成执行计划\r\n4. 执行器调用存储引擎的读写接口进行数据查询\r\n\r\n![image](https://github.com/fzdwx/fzdwx.github.io/assets/65269574/645e5834-d596-4c9e-b4d7-cb10365d60a3)\r\n\r\n\r\n\r\n[tags:#MySQL]","bodyHTML":"\u003cp dir=\"auto\"\u003e一条查询 SQL 的执行过程:\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003eclient 与连接器建立连接，连接器确认 client 认证信息以及权限信息\u003c/li\u003e\n\u003cli\u003e分析器进行词法分析(select, where, update, group by...), 然后进行语法分析\u003c/li\u003e\n\u003cli\u003e优化器选择索引生成执行计划\u003c/li\u003e\n\u003cli\u003e执行器调用存储引擎的读写接口进行数据查询\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/65269574/258571472-645e5834-d596-4c9e-b4d7-cb10365d60a3.png\"\u003e\u003cimg src=\"https://user-images.githubusercontent.com/65269574/258571472-645e5834-d596-4c9e-b4d7-cb10365d60a3.png\" alt=\"image\" style=\"max-width: 100%;\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003c/p\u003e","upvoteCount":1,"url":"https://github.com/fzdwx/fzdwx.github.io/discussions/4#discussioncomment-6643890","authorAssociation":"OWNER","createdAt":"2023-08-05T05:12:23Z","updatedAt":"2023-08-05T11:59:50Z","author":{"login":"fzdwx","avatarUrl":"https://avatars.githubusercontent.com/u/65269574?u=ed3f913168ed04029c8cc0c2504b30299d2bde75\u0026v=4","url":"https://github.com/fzdwx","bio":"","email":"","company":"","location":"","name":"","twitterUsername":""},"reactionGroups":[{"content":"THUMBS_UP","reactors":{"totalCount":1}},{"content":"THUMBS_DOWN","reactors":{"totalCount":0}},{"content":"LAUGH","reactors":{"totalCount":0}},{"content":"HOORAY","reactors":{"totalCount":0}},{"content":"CONFUSED","reactors":{"totalCount":0}},{"content":"HEART","reactors":{"totalCount":0}},{"content":"ROCKET","reactors":{"totalCount":0}},{"content":"EYES","reactors":{"totalCount":0}}],"tags":["#MySQL"]}],"pageInfo":{"hasNextPage":false,"endCursor":"Y3Vyc29yOnYyOpK5MjAyMy0wOC0wOFQxOToyNjozOSswODowMM4AZcAz"}},"reactionGroups":null}
