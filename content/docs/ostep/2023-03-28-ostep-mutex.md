---
group: "ostep"
title: "并发控制-互斥"
date: "2023-03-28T20:09:47+08:00"
layout: "doc"
tags: [os, mutex]
summary: "互斥是一种并发控制机制，用于保证在同一时刻只有一个线程可以访问共享资源。"
---

## 1. 为什么需要互斥?

1. 从指令集的角度看, 一个简单的 ++ 操作可能会被编译为 3 条, load -> add -> store, 一条指令是原子的, 但是 3 条指令就不一定了 —— 操作系统的 Trap 机制
2. 假如这个程序是多线程的, 且这个变量是共享的, 那么就会竞态条件, 比如说第一个线程 load 了 0 并进行 add 得到 1, 在它 store 之前,它被切换出去了, 然后第二个线程来了并运行了一套 load ->add -> store 写入了 0. 这样当第一个线程再次运行时它不知道第二个线程已经对这个变量进行了操作, 从而导致了错误的结果.

## 2. 怎么实现互斥?

### 2.1 原子交换

这是一种通过硬件指令实现的互斥, 也是最简单的一种, 但是它的效率不高, 下面是一个简单的示例:

```go
type Mutex struct {
    locked int32
}

func (m *Mutex) Lock() {
  for xchg(&m.locked, 1) == 1{
    // spin
  }
  m.locked = 1
}

func (m *Mutex) Unlock() {
  m.locked = 0
}

func xchg(addr *int32, new int32) int32 {
  old := *addr
  *addr = new
  return old
}
```

当第一个线程调用了 Lock() 时, 它会将 locked 的值从 0 改为 1, 但是当第二个线程调用 Lock() 时, 它会发现 locked 的值已经是 1 了, 所以它会一直 spin 等待第一个线程将 locked 的值改为 0, 这样就实现了互斥.

而 xchg 就是操作系统提供给我们的一个原子交换指令, 它的作用是将 addr 的值与 new 交换, 并返回 addr 的旧值.

### 2.2 能不能更高效点?

上面这种锁的优点就是实现简单, 就是会浪费很多 CPU 时间, 比如说一个线程在等待另一个线程释放锁时, 它会一直 spin 等待, 这样就会浪费很多 CPU 时间

#### 2.2.1 主动出让时间片

```go {3}
func (m *Mutex) Lock() {
  for xchg(&m.locked, 1) == 1{
    yield()
  }
  m.locked = 1
}
```

当 xchg 失败时, 可以主动调用 yield() 出让时间片, 这样就不会浪费 CPU 时间了.

但是这样同样也有个问题, 假如有很多线程都在等待这个锁, 那么它们都会主动出让时间片, 这样同样效率也很低, 因为这个涉及到线程的切换

#### 2.2.2 休眠

使用休眠的方式来实现互斥, 假设有一个线程列表存放获取这把锁的线程, 当它获取锁失败时就放入休眠列表, 当锁被释放时, 就唤醒休眠列表中的线程.

在 linux 中, futex 就是实现了类似这种机制
